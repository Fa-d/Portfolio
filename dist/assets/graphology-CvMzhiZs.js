import{e as ht}from"./events-CXH2uRM3.js";import{t as J,I as D,c as N}from"./obliterator-ZSrzDlqD.js";function ct(){const r=arguments[0];for(let t=1,e=arguments.length;t<e;t++)if(arguments[t])for(const i in arguments[t])r[i]=arguments[t][i];return r}let b=ct;typeof Object.assign=="function"&&(b=Object.assign);function x(r,t,e,i){const n=r._nodes.get(t);let o=null;return n&&(i==="mixed"?o=n.out&&n.out[e]||n.undirected&&n.undirected[e]:i==="directed"?o=n.out&&n.out[e]:o=n.undirected&&n.undirected[e]),o}function $(r){return typeof r=="object"&&r!==null}function V(r){let t;for(t in r)return!1;return!0}function _(r,t,e){Object.defineProperty(r,t,{enumerable:!1,configurable:!1,writable:!0,value:e})}function A(r,t,e){const i={enumerable:!0,configurable:!0};typeof e=="function"?i.get=e:(i.value=e,i.writable=!1),Object.defineProperty(r,t,i)}function R(r){return!(!$(r)||r.attributes&&!Array.isArray(r.attributes))}function ft(){let r=Math.floor(Math.random()*256)&255;return()=>r++}class T extends Error{constructor(t){super(),this.name="GraphError",this.message=t}}class l extends T{constructor(t){super(t),this.name="InvalidArgumentsGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,l.prototype.constructor)}}class f extends T{constructor(t){super(t),this.name="NotFoundGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,f.prototype.constructor)}}class g extends T{constructor(t){super(t),this.name="UsageGraphError",typeof Error.captureStackTrace=="function"&&Error.captureStackTrace(this,g.prototype.constructor)}}function q(r,t){this.key=r,this.attributes=t,this.clear()}q.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}};function Q(r,t){this.key=r,this.attributes=t,this.clear()}Q.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}};function X(r,t){this.key=r,this.attributes=t,this.clear()}X.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}};function L(r,t,e,i,n){this.key=t,this.attributes=n,this.undirected=r,this.source=e,this.target=i}L.prototype.attach=function(){let r="out",t="in";this.undirected&&(r=t="undirected");const e=this.source.key,i=this.target.key;this.source[r][i]=this,!(this.undirected&&e===i)&&(this.target[t][e]=this)};L.prototype.attachMulti=function(){let r="out",t="in";const e=this.source.key,i=this.target.key;this.undirected&&(r=t="undirected");const n=this.source[r],o=n[i];if(typeof o>"u"){n[i]=this,this.undirected&&e===i||(this.target[t][e]=this);return}o.previous=this,this.next=o,n[i]=this,this.target[t][e]=this};L.prototype.detach=function(){const r=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),delete this.source[e][t],delete this.target[i][r]};L.prototype.detachMulti=function(){const r=this.source.key,t=this.target.key;let e="out",i="in";this.undirected&&(e=i="undirected"),this.previous===void 0?this.next===void 0?(delete this.source[e][t],delete this.target[i][r]):(this.next.previous=void 0,this.source[e][t]=this.next,this.target[i][r]=this.next):(this.previous.next=this.next,this.next!==void 0&&(this.next.previous=this.previous))};const Z=0,tt=1,pt=2,et=3;function S(r,t,e,i,n,o,s){let a,u,d,c;if(i=""+i,e===Z){if(a=r._nodes.get(i),!a)throw new f(`Graph.${t}: could not find the "${i}" node in the graph.`);d=n,c=o}else if(e===et){if(n=""+n,u=r._edges.get(n),!u)throw new f(`Graph.${t}: could not find the "${n}" edge in the graph.`);const h=u.source.key,p=u.target.key;if(i===h)a=u.target;else if(i===p)a=u.source;else throw new f(`Graph.${t}: the "${i}" node is not attached to the "${n}" edge (${h}, ${p}).`);d=o,c=s}else{if(u=r._edges.get(i),!u)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`);e===tt?a=u.source:a=u.target,d=n,c=o}return[a,d,c]}function lt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);return s.attributes[a]}}function gt(r,t,e){r.prototype[t]=function(i,n){const[o]=S(this,t,e,i,n);return o.attributes}}function yt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);return s.attributes.hasOwnProperty(a)}}function wt(r,t,e){r.prototype[t]=function(i,n,o,s){const[a,u,d]=S(this,t,e,i,n,o,s);return a.attributes[u]=d,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function mt(r,t,e){r.prototype[t]=function(i,n,o,s){const[a,u,d]=S(this,t,e,i,n,o,s);if(typeof d!="function")throw new l(`Graph.${t}: updater should be a function.`);const c=a.attributes,h=d(c[u]);return c[u]=h,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:u}),this}}function bt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);return delete s.attributes[a],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:a}),this}}function $t(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);if(!$(a))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return s.attributes=a,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}function Gt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);if(!$(a))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return b(s.attributes,a),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:a}),this}}function kt(r,t,e){r.prototype[t]=function(i,n,o){const[s,a]=S(this,t,e,i,n,o);if(typeof a!="function")throw new l(`Graph.${t}: provided updater is not a function.`);return s.attributes=a(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}const Et=[{name:r=>`get${r}Attribute`,attacher:lt},{name:r=>`get${r}Attributes`,attacher:gt},{name:r=>`has${r}Attribute`,attacher:yt},{name:r=>`set${r}Attribute`,attacher:wt},{name:r=>`update${r}Attribute`,attacher:mt},{name:r=>`remove${r}Attribute`,attacher:bt},{name:r=>`replace${r}Attributes`,attacher:$t},{name:r=>`merge${r}Attributes`,attacher:Gt},{name:r=>`update${r}Attributes`,attacher:kt}];function _t(r){Et.forEach(function({name:t,attacher:e}){e(r,t("Node"),Z),e(r,t("Source"),tt),e(r,t("Target"),pt),e(r,t("Opposite"),et)})}function xt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return o.attributes[n]}}function Dt(r,t,e){r.prototype[t]=function(i){let n;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const o=""+i,s=""+arguments[1];if(n=x(this,o,s,e),!n)throw new f(`Graph.${t}: could not find an edge for the given path ("${o}" - "${s}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,n=this._edges.get(i),!n)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return n.attributes}}function At(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return o.attributes.hasOwnProperty(n)}}function vt(r,t,e){r.prototype[t]=function(i,n,o){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,u=""+n;if(n=arguments[2],o=arguments[3],s=x(this,a,u,e),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return s.attributes[n]=o,this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function Nt(r,t,e){r.prototype[t]=function(i,n,o){let s;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const a=""+i,u=""+n;if(n=arguments[2],o=arguments[3],s=x(this,a,u,e),!s)throw new f(`Graph.${t}: could not find an edge for the given path ("${a}" - "${u}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,s=this._edges.get(i),!s)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof o!="function")throw new l(`Graph.${t}: updater should be a function.`);return s.attributes[n]=o(s.attributes[n]),this.emit("edgeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:n}),this}}function St(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}return delete o.attributes[n],this.emit("edgeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:n}),this}}function Ut(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}function Lt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(!$(n))throw new l(`Graph.${t}: provided attributes are not a plain object.`);return b(o.attributes,n),this.emit("edgeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:n}),this}}function Mt(r,t,e){r.prototype[t]=function(i,n){let o;if(this.type!=="mixed"&&e!=="mixed"&&e!==this.type)throw new g(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new g(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);const s=""+i,a=""+n;if(n=arguments[2],o=x(this,s,a,e),!o)throw new f(`Graph.${t}: could not find an edge for the given path ("${s}" - "${a}").`)}else{if(e!=="mixed")throw new g(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(i=""+i,o=this._edges.get(i),!o)throw new f(`Graph.${t}: could not find the "${i}" edge in the graph.`)}if(typeof n!="function")throw new l(`Graph.${t}: provided updater is not a function.`);return o.attributes=n(o.attributes),this.emit("edgeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}const zt=[{name:r=>`get${r}Attribute`,attacher:xt},{name:r=>`get${r}Attributes`,attacher:Dt},{name:r=>`has${r}Attribute`,attacher:At},{name:r=>`set${r}Attribute`,attacher:vt},{name:r=>`update${r}Attribute`,attacher:Nt},{name:r=>`remove${r}Attribute`,attacher:St},{name:r=>`replace${r}Attributes`,attacher:Ut},{name:r=>`merge${r}Attributes`,attacher:Lt},{name:r=>`update${r}Attributes`,attacher:Mt}];function Ct(r){zt.forEach(function({name:t,attacher:e}){e(r,t("Edge"),"mixed"),e(r,t("DirectedEdge"),"directed"),e(r,t("UndirectedEdge"),"undirected")})}const It=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function jt(r,t,e,i){let n=!1;for(const o in t){if(o===i)continue;const s=t[o];if(n=e(s.key,s.attributes,s.source.key,s.target.key,s.source.attributes,s.target.attributes,s.undirected),r&&n)return s.key}}function Ot(r,t,e,i){let n,o,s,a=!1;for(const u in t)if(u!==i){n=t[u];do{if(o=n.source,s=n.target,a=e(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected),r&&a)return n.key;n=n.next}while(n!==void 0)}}function W(r,t){const e=Object.keys(r),i=e.length;let n,o=0;return new D(function(){do if(n)n=n.next;else{if(o>=i)return{done:!0};const a=e[o++];if(a===t){n=void 0;continue}n=r[a]}while(!n);return{done:!1,value:{edge:n.key,attributes:n.attributes,source:n.source.key,target:n.target.key,sourceAttributes:n.source.attributes,targetAttributes:n.target.attributes,undirected:n.undirected}}})}function Wt(r,t,e,i){const n=t[e];if(!n)return;const o=n.source,s=n.target;if(i(n.key,n.attributes,o.key,s.key,o.attributes,s.attributes,n.undirected)&&r)return n.key}function Kt(r,t,e,i){let n=t[e];if(!n)return;let o=!1;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),r&&o)return n.key;n=n.next}while(n!==void 0)}function K(r,t){let e=r[t];return e.next!==void 0?new D(function(){if(!e)return{done:!0};const i={edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected};return e=e.next,{done:!1,value:i}}):D.of({edge:e.key,attributes:e.attributes,source:e.source.key,target:e.target.key,sourceAttributes:e.source.attributes,targetAttributes:e.target.attributes,undirected:e.undirected})}function Tt(r,t){if(r.size===0)return[];if(t==="mixed"||t===r.type)return typeof Array.from=="function"?Array.from(r._edges.keys()):J(r._edges.keys(),r._edges.size);const e=t==="undirected"?r.undirectedSize:r.directedSize,i=new Array(e),n=t==="undirected",o=r._edges.values();let s=0,a,u;for(;a=o.next(),a.done!==!0;)u=a.value,u.undirected===n&&(i[s++]=u.key);return i}function it(r,t,e,i){if(t.size===0)return;const n=e!=="mixed"&&e!==t.type,o=e==="undirected";let s,a,u=!1;const d=t._edges.values();for(;s=d.next(),s.done!==!0;){if(a=s.value,n&&a.undirected!==o)continue;const{key:c,attributes:h,source:p,target:y}=a;if(u=i(c,h,p.key,y.key,p.attributes,y.attributes,a.undirected),r&&u)return c}}function Pt(r,t){if(r.size===0)return D.empty();const e=t!=="mixed"&&t!==r.type,i=t==="undirected",n=r._edges.values();return new D(function(){let s,a;for(;;){if(s=n.next(),s.done)return s;if(a=s.value,!(e&&a.undirected!==i))break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function P(r,t,e,i,n,o){const s=t?Ot:jt;let a;if(e!=="undirected"&&(i!=="out"&&(a=s(r,n.in,o),r&&a)||i!=="in"&&(a=s(r,n.out,o,i?void 0:n.key),r&&a))||e!=="directed"&&(a=s(r,n.undirected,o),r&&a))return a}function Ft(r,t,e,i){const n=[];return P(!1,r,t,e,i,function(o){n.push(o)}),n}function Bt(r,t,e){let i=D.empty();return r!=="undirected"&&(t!=="out"&&typeof e.in<"u"&&(i=N(i,W(e.in))),t!=="in"&&typeof e.out<"u"&&(i=N(i,W(e.out,t?void 0:e.key)))),r!=="directed"&&typeof e.undirected<"u"&&(i=N(i,W(e.undirected))),i}function F(r,t,e,i,n,o,s){const a=e?Kt:Wt;let u;if(t!=="undirected"&&(typeof n.in<"u"&&i!=="out"&&(u=a(r,n.in,o,s),r&&u)||typeof n.out<"u"&&i!=="in"&&(i||n.key!==o)&&(u=a(r,n.out,o,s),r&&u))||t!=="directed"&&typeof n.undirected<"u"&&(u=a(r,n.undirected,o,s),r&&u))return u}function Rt(r,t,e,i,n){const o=[];return F(!1,r,t,e,i,n,function(s){o.push(s)}),o}function Yt(r,t,e,i){let n=D.empty();return r!=="undirected"&&(typeof e.in<"u"&&t!=="out"&&i in e.in&&(n=N(n,K(e.in,i))),typeof e.out<"u"&&t!=="in"&&i in e.out&&(t||e.key!==i)&&(n=N(n,K(e.out,i)))),r!=="directed"&&typeof e.undirected<"u"&&i in e.undirected&&(n=N(n,K(e.undirected,i))),n}function Ht(r,t){const{name:e,type:i,direction:n}=t;r.prototype[e]=function(o,s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];if(!arguments.length)return Tt(this,i);if(arguments.length===1){o=""+o;const a=this._nodes.get(o);if(typeof a>"u")throw new f(`Graph.${e}: could not find the "${o}" node in the graph.`);return Ft(this.multi,i==="mixed"?this.type:i,n,a)}if(arguments.length===2){o=""+o,s=""+s;const a=this._nodes.get(o);if(!a)throw new f(`Graph.${e}:  could not find the "${o}" source node in the graph.`);if(!this._nodes.has(s))throw new f(`Graph.${e}:  could not find the "${s}" target node in the graph.`);return Rt(i,this.multi,n,a,s)}throw new l(`Graph.${e}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Jt(r,t){const{name:e,type:i,direction:n}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(d,c,h){if(!(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)){if(arguments.length===1)return h=d,it(!1,this,i,h);if(arguments.length===2){d=""+d,h=c;const p=this._nodes.get(d);if(typeof p>"u")throw new f(`Graph.${o}: could not find the "${d}" node in the graph.`);return P(!1,this.multi,i==="mixed"?this.type:i,n,p,h)}if(arguments.length===3){d=""+d,c=""+c;const p=this._nodes.get(d);if(!p)throw new f(`Graph.${o}:  could not find the "${d}" source node in the graph.`);if(!this._nodes.has(c))throw new f(`Graph.${o}:  could not find the "${c}" target node in the graph.`);return F(!1,i,this.multi,n,p,c,h)}throw new l(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};const s="map"+e[0].toUpperCase()+e.slice(1);r.prototype[s]=function(){const d=Array.prototype.slice.call(arguments),c=d.pop();let h;if(d.length===0){let p=0;i!=="directed"&&(p+=this.undirectedSize),i!=="undirected"&&(p+=this.directedSize),h=new Array(p);let y=0;d.push((m,k,G,E,v,z,ut)=>{h[y++]=c(m,k,G,E,v,z,ut)})}else h=[],d.push((p,y,m,k,G,E,v)=>{h.push(c(p,y,m,k,G,E,v))});return this[o].apply(this,d),h};const a="filter"+e[0].toUpperCase()+e.slice(1);r.prototype[a]=function(){const d=Array.prototype.slice.call(arguments),c=d.pop(),h=[];return d.push((p,y,m,k,G,E,v)=>{c(p,y,m,k,G,E,v)&&h.push(p)}),this[o].apply(this,d),h};const u="reduce"+e[0].toUpperCase()+e.slice(1);r.prototype[u]=function(){let d=Array.prototype.slice.call(arguments);if(d.length<2||d.length>4)throw new l(`Graph.${u}: invalid number of arguments (expecting 2, 3 or 4 and got ${d.length}).`);if(typeof d[d.length-1]=="function"&&typeof d[d.length-2]!="function")throw new l(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let c,h;d.length===2?(c=d[0],h=d[1],d=[]):d.length===3?(c=d[1],h=d[2],d=[d[0]]):d.length===4&&(c=d[2],h=d[3],d=[d[0],d[1]]);let p=h;return d.push((y,m,k,G,E,v,z)=>{p=c(p,y,m,k,G,E,v,z)}),this[o].apply(this,d),p}}function Vt(r,t){const{name:e,type:i,direction:n}=t,o="find"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(u,d,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return!1;if(arguments.length===1)return c=u,it(!0,this,i,c);if(arguments.length===2){u=""+u,c=d;const h=this._nodes.get(u);if(typeof h>"u")throw new f(`Graph.${o}: could not find the "${u}" node in the graph.`);return P(!0,this.multi,i==="mixed"?this.type:i,n,h,c)}if(arguments.length===3){u=""+u,d=""+d;const h=this._nodes.get(u);if(!h)throw new f(`Graph.${o}:  could not find the "${u}" source node in the graph.`);if(!this._nodes.has(d))throw new f(`Graph.${o}:  could not find the "${d}" target node in the graph.`);return F(!0,i,this.multi,n,h,d,c)}throw new l(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};const s="some"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[s]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((h,p,y,m,k,G,E)=>d(h,p,y,m,k,G,E)),!!this[o].apply(this,u)};const a="every"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[a]=function(){const u=Array.prototype.slice.call(arguments),d=u.pop();return u.push((h,p,y,m,k,G,E)=>!d(h,p,y,m,k,G,E)),!this[o].apply(this,u)}}function qt(r,t){const{name:e,type:i,direction:n}=t,o=e.slice(0,-1)+"Entries";r.prototype[o]=function(s,a){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return D.empty();if(!arguments.length)return Pt(this,i);if(arguments.length===1){s=""+s;const u=this._nodes.get(s);if(!u)throw new f(`Graph.${o}: could not find the "${s}" node in the graph.`);return Bt(i,n,u)}if(arguments.length===2){s=""+s,a=""+a;const u=this._nodes.get(s);if(!u)throw new f(`Graph.${o}:  could not find the "${s}" source node in the graph.`);if(!this._nodes.has(a))throw new f(`Graph.${o}:  could not find the "${a}" target node in the graph.`);return Yt(i,n,u,a)}throw new l(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}function Qt(r){It.forEach(t=>{Ht(r,t),Jt(r,t),Vt(r,t),qt(r,t)})}const Xt=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function O(){this.A=null,this.B=null}O.prototype.wrap=function(r){this.A===null?this.A=r:this.B===null&&(this.B=r)};O.prototype.has=function(r){return this.A!==null&&r in this.A||this.B!==null&&r in this.B};function C(r,t,e,i,n){for(const o in i){const s=i[o],a=s.source,u=s.target,d=a===e?u:a;if(t&&t.has(d.key))continue;const c=n(d.key,d.attributes);if(r&&c)return d.key}}function B(r,t,e,i,n){if(t!=="mixed"){if(t==="undirected")return C(r,null,i,i.undirected,n);if(typeof e=="string")return C(r,null,i,i[e],n)}const o=new O;let s;if(t!=="undirected"){if(e!=="out"){if(s=C(r,null,i,i.in,n),r&&s)return s;o.wrap(i.in)}if(e!=="in"){if(s=C(r,o,i,i.out,n),r&&s)return s;o.wrap(i.out)}}if(t!=="directed"&&(s=C(r,o,i,i.undirected,n),r&&s))return s}function Zt(r,t,e){if(r!=="mixed"){if(r==="undirected")return Object.keys(e.undirected);if(typeof t=="string")return Object.keys(e[t])}const i=[];return B(!1,r,t,e,function(n){i.push(n)}),i}function I(r,t,e){const i=Object.keys(e),n=i.length;let o=0;return new D(function(){let a=null;do{if(o>=n)return r&&r.wrap(e),{done:!0};const u=e[i[o++]],d=u.source,c=u.target;if(a=d===t?c:d,r&&r.has(a.key)){a=null;continue}}while(a===null);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function te(r,t,e){if(r!=="mixed"){if(r==="undirected")return I(null,e,e.undirected);if(typeof t=="string")return I(null,e,e[t])}let i=D.empty();const n=new O;return r!=="undirected"&&(t!=="out"&&(i=N(i,I(n,e,e.in))),t!=="in"&&(i=N(i,I(n,e,e.out)))),r!=="directed"&&(i=N(i,I(n,e,e.undirected))),i}function ee(r,t){const{name:e,type:i,direction:n}=t;r.prototype[e]=function(o){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return[];o=""+o;const s=this._nodes.get(o);if(typeof s>"u")throw new f(`Graph.${e}: could not find the "${o}" node in the graph.`);return Zt(i==="mixed"?this.type:i,n,s)}}function ie(r,t){const{name:e,type:i,direction:n}=t,o="forEach"+e[0].toUpperCase()+e.slice(1,-1);r.prototype[o]=function(d,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;d=""+d;const h=this._nodes.get(d);if(typeof h>"u")throw new f(`Graph.${o}: could not find the "${d}" node in the graph.`);B(!1,i==="mixed"?this.type:i,n,h,c)};const s="map"+e[0].toUpperCase()+e.slice(1);r.prototype[s]=function(d,c){const h=[];return this[o](d,(p,y)=>{h.push(c(p,y))}),h};const a="filter"+e[0].toUpperCase()+e.slice(1);r.prototype[a]=function(d,c){const h=[];return this[o](d,(p,y)=>{c(p,y)&&h.push(p)}),h};const u="reduce"+e[0].toUpperCase()+e.slice(1);r.prototype[u]=function(d,c,h){if(arguments.length<3)throw new l(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let p=h;return this[o](d,(y,m)=>{p=c(p,y,m)}),p}}function ne(r,t){const{name:e,type:i,direction:n}=t,o=e[0].toUpperCase()+e.slice(1,-1),s="find"+o;r.prototype[s]=function(d,c){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return;d=""+d;const h=this._nodes.get(d);if(typeof h>"u")throw new f(`Graph.${s}: could not find the "${d}" node in the graph.`);return B(!0,i==="mixed"?this.type:i,n,h,c)};const a="some"+o;r.prototype[a]=function(d,c){return!!this[s](d,c)};const u="every"+o;r.prototype[u]=function(d,c){return!this[s](d,(p,y)=>!c(p,y))}}function re(r,t){const{name:e,type:i,direction:n}=t,o=e.slice(0,-1)+"Entries";r.prototype[o]=function(s){if(i!=="mixed"&&this.type!=="mixed"&&i!==this.type)return D.empty();s=""+s;const a=this._nodes.get(s);if(typeof a>"u")throw new f(`Graph.${o}: could not find the "${s}" node in the graph.`);return te(i==="mixed"?this.type:i,n,a)}}function oe(r){Xt.forEach(t=>{ee(r,t),ie(r,t),ne(r,t),re(r,t)})}function j(r,t,e,i,n){const o=i._nodes.values(),s=i.type;let a,u,d,c,h,p;for(;a=o.next(),a.done!==!0;){let y=!1;if(u=a.value,s!=="undirected"){c=u.out;for(d in c){h=c[d];do p=h.target,y=!0,n(u.key,p.key,u.attributes,p.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}if(s!=="directed"){c=u.undirected;for(d in c)if(!(t&&u.key>d)){h=c[d];do p=h.target,p.key!==d&&(p=h.source),y=!0,n(u.key,p.key,u.attributes,p.attributes,h.key,h.attributes,h.undirected),h=h.next;while(h)}}e&&!y&&n(u.key,null,u.attributes,null,null,null,null)}}function se(r,t){const e={key:r};return V(t.attributes)||(e.attributes=b({},t.attributes)),e}function ae(r,t,e){const i={key:t,source:e.source.key,target:e.target.key};return V(e.attributes)||(i.attributes=b({},e.attributes)),r==="mixed"&&e.undirected&&(i.undirected=!0),i}function de(r){if(!$(r))throw new l('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in r))throw new l("Graph.import: serialized node is missing its key.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function ue(r){if(!$(r))throw new l('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in r))throw new l("Graph.import: serialized edge is missing its source.");if(!("target"in r))throw new l("Graph.import: serialized edge is missing its target.");if("attributes"in r&&(!$(r.attributes)||r.attributes===null))throw new l("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in r&&typeof r.undirected!="boolean")throw new l("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}const he=ft(),ce=new Set(["directed","undirected","mixed"]),Y=new Set(["domain","_events","_eventsCount","_maxListeners"]),fe=[{name:r=>`${r}Edge`,generateKey:!0},{name:r=>`${r}DirectedEdge`,generateKey:!0,type:"directed"},{name:r=>`${r}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:r=>`${r}EdgeWithKey`},{name:r=>`${r}DirectedEdgeWithKey`,type:"directed"},{name:r=>`${r}UndirectedEdgeWithKey`,type:"undirected"}],pe={allowSelfLoops:!0,multi:!1,type:"mixed"};function le(r,t,e){if(e&&!$(e))throw new l(`Graph.addNode: invalid attributes. Expecting an object but got "${e}"`);if(t=""+t,e=e||{},r._nodes.has(t))throw new g(`Graph.addNode: the "${t}" node already exist in the graph.`);const i=new r.NodeDataClass(t,e);return r._nodes.set(t,i),r.emit("nodeAdded",{key:t,attributes:e}),i}function H(r,t,e){const i=new r.NodeDataClass(t,e);return r._nodes.set(t,i),r.emit("nodeAdded",{key:t,attributes:e}),i}function nt(r,t,e,i,n,o,s,a){if(!i&&r.type==="undirected")throw new g(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new g(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(a&&!$(a))throw new l(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`);if(o=""+o,s=""+s,a=a||{},!r.allowSelfLoops&&o===s)throw new g(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);const u=r._nodes.get(o),d=r._nodes.get(s);if(!u)throw new f(`Graph.${t}: source node "${o}" not found.`);if(!d)throw new f(`Graph.${t}: target node "${s}" not found.`);const c={key:null,undirected:i,source:o,target:s,attributes:a};if(e)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new g(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!r.multi&&(i?typeof u.undirected[s]<"u":typeof u.out[s]<"u"))throw new g(`Graph.${t}: an edge linking "${o}" to "${s}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);const h=new L(i,n,u,d,a);r._edges.set(n,h);const p=o===s;return i?(u.undirectedDegree++,d.undirectedDegree++,p&&(u.undirectedLoops++,r._undirectedSelfLoopCount++)):(u.outDegree++,d.inDegree++,p&&(u.directedLoops++,r._directedSelfLoopCount++)),r.multi?h.attachMulti():h.attach(),i?r._undirectedSize++:r._directedSize++,c.key=n,r.emit("edgeAdded",c),n}function ge(r,t,e,i,n,o,s,a,u){if(!i&&r.type==="undirected")throw new g(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&r.type==="directed")throw new g(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(a){if(u){if(typeof a!="function")throw new l(`Graph.${t}: invalid updater function. Expecting a function but got "${a}"`)}else if(!$(a))throw new l(`Graph.${t}: invalid attributes. Expecting an object but got "${a}"`)}o=""+o,s=""+s;let d;if(u&&(d=a,a=void 0),!r.allowSelfLoops&&o===s)throw new g(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let c=r._nodes.get(o),h=r._nodes.get(s),p,y;if(!e&&(p=r._edges.get(n),p)){if((p.source.key!==o||p.target.key!==s)&&(!i||p.source.key!==s||p.target.key!==o))throw new g(`Graph.${t}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${s}" target vs. ("${p.source.key}", "${p.target.key}").`);y=p}if(!y&&!r.multi&&c&&(y=i?c.undirected[s]:c.out[s]),y){const v=[y.key,!1,!1,!1];if(u?!d:!a)return v;if(u){const z=y.attributes;y.attributes=d(z),r.emit("edgeAttributesUpdated",{type:"replace",key:y.key,attributes:y.attributes})}else b(y.attributes,a),r.emit("edgeAttributesUpdated",{type:"merge",key:y.key,attributes:y.attributes,data:a});return v}a=a||{},u&&d&&(a=d(a));const m={key:null,undirected:i,source:o,target:s,attributes:a};if(e)n=r._edgeKeyGenerator();else if(n=""+n,r._edges.has(n))throw new g(`Graph.${t}: the "${n}" edge already exists in the graph.`);let k=!1,G=!1;c||(c=H(r,o,{}),k=!0,o===s&&(h=c,G=!0)),h||(h=H(r,s,{}),G=!0),p=new L(i,n,c,h,a),r._edges.set(n,p);const E=o===s;return i?(c.undirectedDegree++,h.undirectedDegree++,E&&(c.undirectedLoops++,r._undirectedSelfLoopCount++)):(c.outDegree++,h.inDegree++,E&&(c.directedLoops++,r._directedSelfLoopCount++)),r.multi?p.attachMulti():p.attach(),i?r._undirectedSize++:r._directedSize++,m.key=n,r.emit("edgeAdded",m),[n,!0,k,G]}function U(r,t){r._edges.delete(t.key);const{source:e,target:i,attributes:n}=t,o=t.undirected,s=e===i;o?(e.undirectedDegree--,i.undirectedDegree--,s&&(e.undirectedLoops--,r._undirectedSelfLoopCount--)):(e.outDegree--,i.inDegree--,s&&(e.directedLoops--,r._directedSelfLoopCount--)),r.multi?t.detachMulti():t.detach(),o?r._undirectedSize--:r._directedSize--,r.emit("edgeDropped",{key:t.key,attributes:n,source:e.key,target:i.key,undirected:o})}class w extends ht.EventEmitter{constructor(t){if(super(),t=b({},pe,t),typeof t.multi!="boolean")throw new l(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${t.multi}".`);if(!ce.has(t.type))throw new l(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${t.type}".`);if(typeof t.allowSelfLoops!="boolean")throw new l(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${t.allowSelfLoops}".`);const e=t.type==="mixed"?q:t.type==="directed"?Q:X;_(this,"NodeDataClass",e);const i="geid_"+he()+"_";let n=0;const o=()=>{let s;do s=i+n++;while(this._edges.has(s));return s};_(this,"_attributes",{}),_(this,"_nodes",new Map),_(this,"_edges",new Map),_(this,"_directedSize",0),_(this,"_undirectedSize",0),_(this,"_directedSelfLoopCount",0),_(this,"_undirectedSelfLoopCount",0),_(this,"_edgeKeyGenerator",o),_(this,"_options",t),Y.forEach(s=>_(this,s,this[s])),A(this,"order",()=>this._nodes.size),A(this,"size",()=>this._edges.size),A(this,"directedSize",()=>this._directedSize),A(this,"undirectedSize",()=>this._undirectedSize),A(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),A(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),A(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),A(this,"multi",this._options.multi),A(this,"type",this._options.type),A(this,"allowSelfLoops",this._options.allowSelfLoops),A(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(t){return this._nodes.has(""+t)}hasDirectedEdge(t,e){if(this.type==="undirected")return!1;if(arguments.length===1){const i=""+t,n=this._edges.get(i);return!!n&&!n.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.out.hasOwnProperty(e):!1}throw new l(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(t,e){if(this.type==="directed")return!1;if(arguments.length===1){const i=""+t,n=this._edges.get(i);return!!n&&n.undirected}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?i.undirected.hasOwnProperty(e):!1}throw new l(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(t,e){if(arguments.length===1){const i=""+t;return this._edges.has(i)}else if(arguments.length===2){t=""+t,e=""+e;const i=this._nodes.get(t);return i?typeof i.out<"u"&&i.out.hasOwnProperty(e)||typeof i.undirected<"u"&&i.undirected.hasOwnProperty(e):!1}throw new l(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(t,e){if(this.type==="undirected")return;if(t=""+t,e=""+e,this.multi)throw new g("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");const i=this._nodes.get(t);if(!i)throw new f(`Graph.directedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.directedEdge: could not find the "${e}" target node in the graph.`);const n=i.out&&i.out[e]||void 0;if(n)return n.key}undirectedEdge(t,e){if(this.type==="directed")return;if(t=""+t,e=""+e,this.multi)throw new g("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");const i=this._nodes.get(t);if(!i)throw new f(`Graph.undirectedEdge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.undirectedEdge: could not find the "${e}" target node in the graph.`);const n=i.undirected&&i.undirected[e]||void 0;if(n)return n.key}edge(t,e){if(this.multi)throw new g("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.edge: could not find the "${t}" source node in the graph.`);if(!this._nodes.has(e))throw new f(`Graph.edge: could not find the "${e}" target node in the graph.`);const n=i.out&&i.out[e]||i.undirected&&i.undirected[e]||void 0;if(n)return n.key}areDirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areDirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in||e in i.out}areOutNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areOutNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.out}areInNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areInNeighbors: could not find the "${t}" node in the graph.`);return this.type==="undirected"?!1:e in i.in}areUndirectedNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areUndirectedNeighbors: could not find the "${t}" node in the graph.`);return this.type==="directed"?!1:e in i.undirected}areNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&(e in i.in||e in i.out)||this.type!=="directed"&&e in i.undirected}areInboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areInboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.in||this.type!=="directed"&&e in i.undirected}areOutboundNeighbors(t,e){t=""+t,e=""+e;const i=this._nodes.get(t);if(!i)throw new f(`Graph.areOutboundNeighbors: could not find the "${t}" node in the graph.`);return this.type!=="undirected"&&e in i.out||this.type!=="directed"&&e in i.undirected}inDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree}outDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree}directedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.directedDegree: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree}undirectedDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.undirectedDegree: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree}inboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree),i}outboundDegree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outboundDegree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.outDegree),i}degree(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.degree: could not find the "${t}" node in the graph.`);let i=0;return this.type!=="directed"&&(i+=e.undirectedDegree),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree),i}inDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree-e.directedLoops}outDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.outDegree-e.directedLoops}directedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.directedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="undirected"?0:e.inDegree+e.outDegree-e.directedLoops*2}undirectedDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);return this.type==="directed"?0:e.undirectedDegree-e.undirectedLoops*2}inboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree,n+=e.directedLoops),i-n}outboundDegreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.outDegree,n+=e.directedLoops),i-n}degreeWithoutSelfLoops(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.degreeWithoutSelfLoops: could not find the "${t}" node in the graph.`);let i=0,n=0;return this.type!=="directed"&&(i+=e.undirectedDegree,n+=e.undirectedLoops*2),this.type!=="undirected"&&(i+=e.inDegree+e.outDegree,n+=e.directedLoops*2),i-n}source(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.source: could not find the "${t}" edge in the graph.`);return e.source.key}target(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.target: could not find the "${t}" edge in the graph.`);return e.target.key}extremities(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.extremities: could not find the "${t}" edge in the graph.`);return[e.source.key,e.target.key]}opposite(t,e){t=""+t,e=""+e;const i=this._edges.get(e);if(!i)throw new f(`Graph.opposite: could not find the "${e}" edge in the graph.`);const n=i.source.key,o=i.target.key;if(t===n)return o;if(t===o)return n;throw new f(`Graph.opposite: the "${t}" node is not attached to the "${e}" edge (${n}, ${o}).`)}hasExtremity(t,e){t=""+t,e=""+e;const i=this._edges.get(t);if(!i)throw new f(`Graph.hasExtremity: could not find the "${t}" edge in the graph.`);return i.source.key===e||i.target.key===e}isUndirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isUndirected: could not find the "${t}" edge in the graph.`);return e.undirected}isDirected(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isDirected: could not find the "${t}" edge in the graph.`);return!e.undirected}isSelfLoop(t){t=""+t;const e=this._edges.get(t);if(!e)throw new f(`Graph.isSelfLoop: could not find the "${t}" edge in the graph.`);return e.source===e.target}addNode(t,e){return le(this,t,e).key}mergeNode(t,e){if(e&&!$(e))throw new l(`Graph.mergeNode: invalid attributes. Expecting an object but got "${e}"`);t=""+t,e=e||{};let i=this._nodes.get(t);return i?(e&&(b(i.attributes,e),this.emit("nodeAttributesUpdated",{type:"merge",key:t,attributes:i.attributes,data:e})),[t,!1]):(i=new this.NodeDataClass(t,e),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:e}),[t,!0])}updateNode(t,e){if(e&&typeof e!="function")throw new l(`Graph.updateNode: invalid updater function. Expecting a function but got "${e}"`);t=""+t;let i=this._nodes.get(t);if(i){if(e){const o=i.attributes;i.attributes=e(o),this.emit("nodeAttributesUpdated",{type:"replace",key:t,attributes:i.attributes})}return[t,!1]}const n=e?e({}):{};return i=new this.NodeDataClass(t,n),this._nodes.set(t,i),this.emit("nodeAdded",{key:t,attributes:n}),[t,!0]}dropNode(t){t=""+t;const e=this._nodes.get(t);if(!e)throw new f(`Graph.dropNode: could not find the "${t}" node in the graph.`);let i;if(this.type!=="undirected"){for(const n in e.out){i=e.out[n];do U(this,i),i=i.next;while(i)}for(const n in e.in){i=e.in[n];do U(this,i),i=i.next;while(i)}}if(this.type!=="directed")for(const n in e.undirected){i=e.undirected[n];do U(this,i),i=i.next;while(i)}this._nodes.delete(t),this.emit("nodeDropped",{key:t,attributes:e.attributes})}dropEdge(t){let e;if(arguments.length>1){const i=""+arguments[0],n=""+arguments[1];if(e=x(this,i,n,this.type),!e)throw new f(`Graph.dropEdge: could not find the "${i}" -> "${n}" edge in the graph.`)}else if(t=""+t,e=this._edges.get(t),!e)throw new f(`Graph.dropEdge: could not find the "${t}" edge in the graph.`);return U(this,e),this}dropDirectedEdge(t,e){if(arguments.length<2)throw new g("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new g("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");t=""+t,e=""+e;const i=x(this,t,e,"directed");if(!i)throw new f(`Graph.dropDirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return U(this,i),this}dropUndirectedEdge(t,e){if(arguments.length<2)throw new g("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new g("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");const i=x(this,t,e,"undirected");if(!i)throw new f(`Graph.dropUndirectedEdge: could not find a "${t}" -> "${e}" edge in the graph.`);return U(this,i),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){const t=this._nodes.values();let e;for(;e=t.next(),e.done!==!0;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(t){return this._attributes[t]}getAttributes(){return this._attributes}hasAttribute(t){return this._attributes.hasOwnProperty(t)}setAttribute(t,e){return this._attributes[t]=e,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}updateAttribute(t,e){if(typeof e!="function")throw new l("Graph.updateAttribute: updater should be a function.");const i=this._attributes[t];return this._attributes[t]=e(i),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:t}),this}removeAttribute(t){return delete this._attributes[t],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:t}),this}replaceAttributes(t){if(!$(t))throw new l("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=t,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(t){if(!$(t))throw new l("Graph.mergeAttributes: provided attributes are not a plain object.");return b(this._attributes,t),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:t}),this}updateAttributes(t){if(typeof t!="function")throw new l("Graph.updateAttributes: provided updater is not a function.");return this._attributes=t(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(t,e){if(typeof t!="function")throw new l("Graph.updateEachNodeAttributes: expecting an updater function.");if(e&&!R(e))throw new l("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._nodes.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,o.attributes=t(o.key,o.attributes);this.emit("eachNodeAttributesUpdated",{hints:e||null})}updateEachEdgeAttributes(t,e){if(typeof t!="function")throw new l("Graph.updateEachEdgeAttributes: expecting an updater function.");if(e&&!R(e))throw new l("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");const i=this._edges.values();let n,o,s,a;for(;n=i.next(),n.done!==!0;)o=n.value,s=o.source,a=o.target,o.attributes=t(o.key,o.attributes,s.key,a.key,s.attributes,a.attributes,o.undirected);this.emit("eachEdgeAttributesUpdated",{hints:e||null})}forEachAdjacencyEntry(t){if(typeof t!="function")throw new l("Graph.forEachAdjacencyEntry: expecting a callback.");j(!1,!1,!1,this,t)}forEachAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new l("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!1,!0,this,t)}forEachAssymetricAdjacencyEntry(t){if(typeof t!="function")throw new l("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");j(!1,!0,!1,this,t)}forEachAssymetricAdjacencyEntryWithOrphans(t){if(typeof t!="function")throw new l("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");j(!1,!0,!0,this,t)}nodes(){return typeof Array.from=="function"?Array.from(this._nodes.keys()):J(this._nodes.keys(),this._nodes.size)}forEachNode(t){if(typeof t!="function")throw new l("Graph.forEachNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)n=i.value,t(n.key,n.attributes)}findNode(t){if(typeof t!="function")throw new l("Graph.findNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,t(n.key,n.attributes))return n.key}mapNodes(t){if(typeof t!="function")throw new l("Graph.mapNode: expecting a callback.");const e=this._nodes.values();let i,n;const o=new Array(this.order);let s=0;for(;i=e.next(),i.done!==!0;)n=i.value,o[s++]=t(n.key,n.attributes);return o}someNode(t){if(typeof t!="function")throw new l("Graph.someNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,t(n.key,n.attributes))return!0;return!1}everyNode(t){if(typeof t!="function")throw new l("Graph.everyNode: expecting a callback.");const e=this._nodes.values();let i,n;for(;i=e.next(),i.done!==!0;)if(n=i.value,!t(n.key,n.attributes))return!1;return!0}filterNodes(t){if(typeof t!="function")throw new l("Graph.filterNodes: expecting a callback.");const e=this._nodes.values();let i,n;const o=[];for(;i=e.next(),i.done!==!0;)n=i.value,t(n.key,n.attributes)&&o.push(n.key);return o}reduceNodes(t,e){if(typeof t!="function")throw new l("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new l("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let i=e;const n=this._nodes.values();let o,s;for(;o=n.next(),o.done!==!0;)s=o.value,i=t(i,s.key,s.attributes);return i}nodeEntries(){const t=this._nodes.values();return new D(()=>{const e=t.next();if(e.done)return e;const i=e.value;return{value:{node:i.key,attributes:i.attributes},done:!1}})}export(){const t=new Array(this._nodes.size);let e=0;this._nodes.forEach((n,o)=>{t[e++]=se(o,n)});const i=new Array(this._edges.size);return e=0,this._edges.forEach((n,o)=>{i[e++]=ae(this.type,o,n)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:t,edges:i}}import(t,e=!1){if(t instanceof w)return t.forEachNode((u,d)=>{e?this.mergeNode(u,d):this.addNode(u,d)}),t.forEachEdge((u,d,c,h,p,y,m)=>{e?m?this.mergeUndirectedEdgeWithKey(u,c,h,d):this.mergeDirectedEdgeWithKey(u,c,h,d):m?this.addUndirectedEdgeWithKey(u,c,h,d):this.addDirectedEdgeWithKey(u,c,h,d)}),this;if(!$(t))throw new l("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(t.attributes){if(!$(t.attributes))throw new l("Graph.import: invalid attributes. Expecting a plain object.");e?this.mergeAttributes(t.attributes):this.replaceAttributes(t.attributes)}let i,n,o,s,a;if(t.nodes){if(o=t.nodes,!Array.isArray(o))throw new l("Graph.import: invalid nodes. Expecting an array.");for(i=0,n=o.length;i<n;i++){s=o[i],de(s);const{key:u,attributes:d}=s;e?this.mergeNode(u,d):this.addNode(u,d)}}if(t.edges){let u=!1;if(this.type==="undirected"&&(u=!0),o=t.edges,!Array.isArray(o))throw new l("Graph.import: invalid edges. Expecting an array.");for(i=0,n=o.length;i<n;i++){a=o[i],ue(a);const{source:d,target:c,attributes:h,undirected:p=u}=a;let y;"key"in a?(y=e?p?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:p?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey,y.call(this,a.key,d,c,h)):(y=e?p?this.mergeUndirectedEdge:this.mergeDirectedEdge:p?this.addUndirectedEdge:this.addDirectedEdge,y.call(this,d,c,h))}}return this}nullCopy(t){const e=new w(b({},this._options,t));return e.replaceAttributes(b({},this.getAttributes())),e}emptyCopy(t){const e=this.nullCopy(t);return this._nodes.forEach((i,n)=>{const o=b({},i.attributes);i=new e.NodeDataClass(n,o),e._nodes.set(n,i)}),e}copy(t){if(t=t||{},typeof t.type=="string"&&t.type!==this.type&&t.type!=="mixed")throw new g(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${t.type}" because this would mean losing information about the current graph.`);if(typeof t.multi=="boolean"&&t.multi!==this.multi&&t.multi!==!0)throw new g("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if(typeof t.allowSelfLoops=="boolean"&&t.allowSelfLoops!==this.allowSelfLoops&&t.allowSelfLoops!==!0)throw new g("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");const e=this.emptyCopy(t),i=this._edges.values();let n,o;for(;n=i.next(),n.done!==!0;)o=n.value,nt(e,"copy",!1,o.undirected,o.key,o.source.key,o.target.key,b({},o.attributes));return e}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){const t={};this._nodes.forEach((o,s)=>{t[s]=o.attributes});const e={},i={};this._edges.forEach((o,s)=>{const a=o.undirected?"--":"->";let u="",d=o.source.key,c=o.target.key,h;o.undirected&&d>c&&(h=d,d=c,c=h);const p=`(${d})${a}(${c})`;s.startsWith("geid_")?this.multi&&(typeof i[p]>"u"?i[p]=0:i[p]++,u+=`${i[p]}. `):u+=`[${s}]: `,u+=p,e[u]=o.attributes});const n={};for(const o in this)this.hasOwnProperty(o)&&!Y.has(o)&&typeof this[o]!="function"&&typeof o!="symbol"&&(n[o]=this[o]);return n.attributes=this._attributes,n.nodes=t,n.edges=e,_(n,"constructor",this.constructor),n}}typeof Symbol<"u"&&(w.prototype[Symbol.for("nodejs.util.inspect.custom")]=w.prototype.inspect);fe.forEach(r=>{["add","merge","update"].forEach(t=>{const e=r.name(t),i=t==="add"?nt:ge;r.generateKey?w.prototype[e]=function(n,o,s){return i(this,e,!0,(r.type||this.type)==="undirected",null,n,o,s,t==="update")}:w.prototype[e]=function(n,o,s,a){return i(this,e,!1,(r.type||this.type)==="undirected",n,o,s,a,t==="update")}})});_t(w);Ct(w);Qt(w);oe(w);class rt extends w{constructor(t){const e=b({type:"directed"},t);if("multi"in e&&e.multi!==!1)throw new l("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="directed")throw new l('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class ot extends w{constructor(t){const e=b({type:"undirected"},t);if("multi"in e&&e.multi!==!1)throw new l("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if(e.type!=="undirected")throw new l('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class st extends w{constructor(t){const e=b({multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(e)}}class at extends w{constructor(t){const e=b({type:"directed",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="directed")throw new l('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}class dt extends w{constructor(t){const e=b({type:"undirected",multi:!0},t);if("multi"in e&&e.multi!==!0)throw new l("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if(e.type!=="undirected")throw new l('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');super(e)}}function M(r){r.from=function(t,e){const i=b({},t.options,e),n=new r(i);return n.import(t),n}}M(w);M(rt);M(ot);M(st);M(at);M(dt);w.Graph=w;w.DirectedGraph=rt;w.UndirectedGraph=ot;w.MultiGraph=st;w.MultiDirectedGraph=at;w.MultiUndirectedGraph=dt;w.InvalidArgumentsGraphError=l;w.NotFoundGraphError=f;w.UsageGraphError=g;export{w as G};
