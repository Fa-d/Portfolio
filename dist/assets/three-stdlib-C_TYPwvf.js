import{B as z,z as H,F as D,g as n}from"./three-D6Fw_2Dt.js";const I=(c,r)=>{const e=c[0].index!==null,t=new Set(Object.keys(c[0].attributes)),f=new Set(Object.keys(c[0].morphAttributes)),o={},u={},p=c[0].morphTargetsRelative,l=new z;let M=0;if(c.forEach((s,a)=>{let d=0;if(e!==(s.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(let i in s.attributes){if(!t.has(i))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+'. All geometries must have compatible attributes; make sure "'+i+'" attribute exists among all geometries, or in none of them.'),null;o[i]===void 0&&(o[i]=[]),o[i].push(s.attributes[i]),d++}if(d!==t.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". Make sure all geometries have the same number of attributes."),null;if(p!==s.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(let i in s.morphAttributes){if(!f.has(i))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+".  .morphAttributes must be consistent throughout all geometries."),null;u[i]===void 0&&(u[i]=[]),u[i].push(s.morphAttributes[i])}if(l.userData.mergedUserData=l.userData.mergedUserData||[],l.userData.mergedUserData.push(s.userData),r){let i;if(s.index)i=s.index.count;else if(s.attributes.position!==void 0)i=s.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". The geometry must have either an index or a position attribute"),null;l.addGroup(M,i,a),M+=i}}),e){let s=0;const a=[];c.forEach(d=>{const i=d.index;for(let x=0;x<i.count;++x)a.push(i.getX(x)+s);s+=d.attributes.position.count}),l.setIndex(a)}for(let s in o){const a=U(o[s]);if(!a)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+s+" attribute."),null;l.setAttribute(s,a)}for(let s in u){const a=u[s][0].length;if(a===0)break;l.morphAttributes=l.morphAttributes||{},l.morphAttributes[s]=[];for(let d=0;d<a;++d){const i=[];for(let R=0;R<u[s].length;++R)i.push(u[s][R][d]);const x=U(i);if(!x)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+s+" morphAttribute."),null;l.morphAttributes[s].push(x)}}return l},U=c=>{let r,e,t,f=0;if(c.forEach(o=>{if(r===void 0&&(r=o.array.constructor),r!==o.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(e===void 0&&(e=o.itemSize),e!==o.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(t===void 0&&(t=o.normalized),t!==o.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;f+=o.array.length}),r&&e){const o=new r(f);let u=0;return c.forEach(p=>{o.set(p.array,u),u+=p.array.length}),new H(o,e,t)}},S=new D,C=new n,w=new n,m=new n,y=new n,h=new n,g=new n,b=new n,v=new n,B=new n,E=new n,G=new n,A=new n,F=new n,T=new n;class j{constructor(r,e,t){this.camera=r,this.scene=e,this.startPoint=new n,this.endPoint=new n,this.collection=[],this.deep=t||Number.MAX_VALUE}select(r,e){return this.startPoint=r||this.startPoint,this.endPoint=e||this.endPoint,this.collection=[],this.updateFrustum(this.startPoint,this.endPoint),this.searchChildInFrustum(S,this.scene),this.collection}updateFrustum(r,e){if(r=r||this.startPoint,e=e||this.endPoint,r.x===e.x&&(e.x+=Number.EPSILON),r.y===e.y&&(e.y+=Number.EPSILON),this.camera.updateProjectionMatrix(),this.camera.updateMatrixWorld(),this.camera.isPerspectiveCamera){w.copy(r),w.x=Math.min(r.x,e.x),w.y=Math.max(r.y,e.y),e.x=Math.max(r.x,e.x),e.y=Math.min(r.y,e.y),m.setFromMatrixPosition(this.camera.matrixWorld),y.copy(w),h.set(e.x,w.y,0),g.copy(e),b.set(w.x,e.y,0),y.unproject(this.camera),h.unproject(this.camera),g.unproject(this.camera),b.unproject(this.camera),A.copy(y).sub(m),F.copy(h).sub(m),T.copy(g).sub(m),A.normalize(),F.normalize(),T.normalize(),A.multiplyScalar(this.deep),F.multiplyScalar(this.deep),T.multiplyScalar(this.deep),A.add(m),F.add(m),T.add(m);var t=S.planes;t[0].setFromCoplanarPoints(m,y,h),t[1].setFromCoplanarPoints(m,h,g),t[2].setFromCoplanarPoints(g,b,m),t[3].setFromCoplanarPoints(b,y,m),t[4].setFromCoplanarPoints(h,g,b),t[5].setFromCoplanarPoints(T,F,A),t[5].normal.multiplyScalar(-1)}else if(this.camera.isOrthographicCamera){const f=Math.min(r.x,e.x),o=Math.max(r.y,e.y),u=Math.max(r.x,e.x),p=Math.min(r.y,e.y);y.set(f,o,-1),h.set(u,o,-1),g.set(u,p,-1),b.set(f,p,-1),v.set(f,o,1),B.set(u,o,1),E.set(u,p,1),G.set(f,p,1),y.unproject(this.camera),h.unproject(this.camera),g.unproject(this.camera),b.unproject(this.camera),v.unproject(this.camera),B.unproject(this.camera),E.unproject(this.camera),G.unproject(this.camera);var t=S.planes;t[0].setFromCoplanarPoints(y,v,B),t[1].setFromCoplanarPoints(h,B,E),t[2].setFromCoplanarPoints(E,G,b),t[3].setFromCoplanarPoints(G,v,y),t[4].setFromCoplanarPoints(h,g,b),t[5].setFromCoplanarPoints(E,B,v),t[5].normal.multiplyScalar(-1)}else console.error("THREE.SelectionBox: Unsupported camera type.")}searchChildInFrustum(r,e){if((e.isMesh||e.isLine||e.isPoints)&&e.material!==void 0&&(e.geometry.boundingSphere===null&&e.geometry.computeBoundingSphere(),C.copy(e.geometry.boundingSphere.center),C.applyMatrix4(e.matrixWorld),r.containsPoint(C)&&this.collection.push(e)),e.children.length>0)for(let t=0;t<e.children.length;t++)this.searchChildInFrustum(r,e.children[t])}}export{j as S,I as m};
